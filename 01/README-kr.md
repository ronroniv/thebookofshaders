# 시작하기
## 프래그먼트 셰이더란?

이전 챕터에서 셰이더란 컴퓨터 그래픽스에 있어 구텐베르크 인쇄술과 같다고 했다. 왜 그럴까? 그보다 셰이더란 대체 무엇인가?

![글자 단위 복제에서 페이지 단위 복제로 (왼쪽: 윌리엄 블레이즈 (1891), 오른쪽: 롤트휠러 (1920))](print.png)

이미 컴퓨터로 그림을 그려본 경험이 있다면 그 과정에 원을 그리고, 사각형을 그리고, 선을, 삼각형을 그리면서 원하는 이미지를 구성한다는 점을 알 것이다. 그 과정은 편지나 책을 손수 쓰는 과정과 닮아있다. 작업에 작업을 이어하는 명령어 집합이라고 볼 수 있다.

셰이더 역시 명령어 집합이지만 그 명령어들 모두 화면 위 모든 픽셀에 대해 동시에 실행된다. 이 말은 여러분이 쓴 코드가 화면 위 픽셀의 위치에 따라 다르게 실행된다는 뜻이다. 마치 활자 인쇄처럼 여러분의 프로그램은 위치를 받아 색을 반환하는 함수처럼 작동하고, 컴파일되면 굉장히 빠르게 실행된다.

![중국 활자](typepress.jpg)

## 셰이더는 왜 빠를까?

그 대답으로 *병렬 처리*의 경이로움을 이야기해보자.

CPU가 하나의 큰 공장같은 파이프라고 가정하자. 파이프로 들어오는것들은 어떤 작업들이고, 그 작업들이 파이프를 지나면 나오면서 결과가 된다고 하자. 어떤 작업은 크고 복잡하기도 할것이고 어떤건 매우 단순하기도 할것이다. 그리고 컴퓨터는 설계상 절차적으로 작업을 실행하도록 되어 있다; 작업하나가 끝나야 그다음 작업이 시작된다. 근대의 컴퓨터들은 4개의 프로세서로 이루어진 그룹이 이런 파이프처럼 작동하는데, 역시 순차적으로 작업을 하나 끝내고 다음걸 시작하는 방식이다. 각 파이프는 *thread*라고도 알려져 있다.

CPU가 하나의 커다란 공장 파이프고 마치 공장 라인처럼 CPU에 전달되는 모든 작업이 그 속을 지나간다고 생각해보자. 어떤 작업은 다른 것에 비해 커서 처리에 더 많은 시간과 에너지가 필요하다. 처리 능력이 더 필요하다고 할 수 있다. 컴퓨터의 구조 상 작업은 연속으로 실행되어야 한다. 한 번에 하나의 작업만 끝낼 수 있다. 보통 요즘 컴퓨터들에는 이런 파이프처럼 작동하는 프로세서 네 개가 작업들을 처리하면서 부드럽게 작동한다. 각 파이프는 *쓰레드*라고 부른다.

![CPU](00.jpeg)

비디오 게임이과 기타 그래픽 애플리케이션들은 다른 프로그램들보다 더 큰 처리 능력을 요구한다. 그래픽 콘텐츠 때문에 상당한 수의 픽셀 연산을 해야 하기 때문이다. 화면 위 모든 픽셀을 계산해야 하고 3D 게임들에서는 지오메트리와 원근 계산 또한 해야 한다.

다시 파이프와 작업 비유로 돌아가보자. 화면 위 각 픽셀은 하나의 작고 단순한 작업을 나타낸다. 개별적으로 각 픽셀 작업은 CPU에게 별 문제되지 않지만, (여기서 문제가 생긴다) 이 아주 작은 작업을 화면 위 각 픽셀마다 수행해야 한다! 옛날 800x600 화면에서는 프레임당 480,000 픽셀이 처리되어야 하고, 따라서 초당 14,000,000번의 계산을 해야 한다! 맞다! 이건 마이크로프로세서를 과부하시킬 정도로 큰 문제다. 초당 60프레임으로 돌아가는 현대의 2080x1800 해상도 레티나 디스플레이에서는 초당 계산이 311,040,000번까지 간다. 그래픽스 엔지니어들은 이 문제를 어떻게 해결할까?

![](03.jpeg)

여기서 병렬 처리가 좋은 해법이 된다. 크고 강력한 마이크로프로세서 (혹은 *파이프*) 몇 개 대신에 아주 작은 마이크로프로세서를 많이 병렬로 동시에 돌아가게 하는 것이 현명하다. 그것이 바로 그래픽 처리 장치, GPU다.

![GPU](04.jpeg)

그 작은 마이크로프로세서들을 파이프로 만들어진 테이블로, 각 픽셀의 데이터를 탁구공으로 생각해보자. 초당 14,400,000개의 탁구공은 대부분 파이프를 막아버린다. 하지만 가로 800개, 세로 600개의 작은 파이프로 이루어진 테이블에 초당 480,000픽셀을 30번 떨어트리는 작업은 순조롭게 진행될 수 있다. 더 높은 해상도에서도 마찬가지다. 병렬된 하드웨어가 많은 만큼 더 많은 작업을 해낼 수 있다.

GPU의 또다른 "초능력"은 하드웨어로 가속되는 특별한 수학 함수들이다. 덕분에 복잡한 수학 연산을 소프트웨어 대신 마이크로치비 직접 해결할 수 있다. 즉 더 빠른, 전기가 흐르는 속도 만큼 빠른 삼각함수 및 행렬 연산이 가능하다.

## GLSL이란?

GLSL은 OpenGL 셰이딩 언어(OpenGL Shading Language)의 줄임말로 이어지는 챕터들에서 보게 될 셰이더 프로그램 표준이다. 하드웨어와 운영체제에 따라 다른 셰이더가 사용되기도 한다. 이 책에서는 [크로노스 그룹](https://www.khronos.org/opengl/)이 관리하는 OpenGL 규격을 따른다. OpenGL의 역사를 이해하면 그 기묘한 관습들을 이해하는 데 도움이 될 수 있으니 다음을 읽어보길 권한다: [openglbook.com/chapter-0-preface-what-is-opengl.html](http://openglbook.com/chapter-0-preface-what-is-opengl.html)

## 왜 사람들은 셰이더를 어렵다고 할까?

벤 삼촌 말하길, "큰 힘에는 큰 책임이 따른다." 병렬 계산도 마찬가지다. GPU의 강력한 아키텍처 설계에는 그만의 제약과 제한이 뒤따른다.

모든 파이프, 그러니까 쓰레드를 병렬로 돌리려면 다른 모든 쓰레드와 독립되어야 한다. 우리는 쓰레드가 다른 쓰레드들이 하는 일에는 *장님*이라고 표현한다. 이런 제약으로 모든 데이터는 반드시 같은 방향으로 흘러야 한다. 때문에 다른 쓰레드의 처리 결과를 확인하거나 입력 데이터를 수정하거나 한 쓰레드의 결과를 다르 데이터로 전달하는 일은 불가능하다. 쓰레드 사이의 소통을 허용하면 데이터의 완전성이 위험하게 된다.

게다가 GPU는 모든 병렬 마이크로프로세서(파이프)를 계속 바쁘게 한다. 파이프는 어떤 작업을 끝내자마자 새로 처리할 정보를 받게 된다. 쓰레드는 자기가 바로 이전에 무엇을 했는지 알 수도 없다. 운영체제 UI의 버튼을 그렸다가, 게임에서 하늘의 일부분을 그렸다가, 이메일의 텍스트를 표시했다가 하는 식이다. 각 쓰레드는 **장님**일뿐 아니라 **기억 능력도 없다**. 결과 픽셀을 그 위치에 따라 바꾸는 함수를 코딩하는 데 필요한 추상화와 함께 장님과 기억 없음 때문에 시작하는 프로그래머들에게는 셰이더가 까다롭게 느껴진다.

걱정하지 말자! 이어지는 챕터들에서 간단한 것부터 복잡한 셰이딩 연산까지 차근차근 배워볼 것이다. 현대 웹 브라우저에서 이 책을 읽고 있다면 상호작용하는 예시들을 가지고 놀아볼 수 있으니 좋을 것이다. 그러니까 이제 더이상 서론을 그만 두고 *Next >>*를 눌러 코드로 뛰어들자!