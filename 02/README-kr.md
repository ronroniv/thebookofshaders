## Hello World!

보통 새로운 언어를 배우는 첫 단계로 "Hello World!" 예시를 쓴다. 열정적인 환영 메시지를 출력하면서 앞으로 펼쳐진 기회를 표명한는 간단한 한 줄 프로그램이다.

GPU 세상에서 텍스트 출력은 첫 단계치고는 과하게 복잡하다. 대신 이 책에서는 환영하는 밝은 색으로 열정을 표출해보자!

<div class="codeAndCanvas" data="hello_world.frag"></div>

이 책을 브라우저에서 읽고 있다면 위 구간은 만져볼 수 있다. 원하면 코드에서 어느 부분이든 클릭해서 바꿔볼 수 있다는 말이다. GPU 아키텍처가 셰이더를 *즉석에서* 셰이더를 컴파일하고 교체하는 덕분에 변경점은 즉시 반영된다. 6번 줄에 있는 값들을 바꿔서 한 번 시험해보라.

별로 대단할 것 없어 보이는 간단한 코드지만 상당한 정보를 추론해볼 수 있다:

1. 셰이더 언어는 마지막에 색상 값을 반환하는 하나의 `main` 함수가 있다. 이것은 C와 비슷하다.

2. 마지막에 반환되는 픽셀 색은 전역 변수 `gl_FragColor`에 대입된다.

3. 이 C 스타일 언어에는 내장된 '변수' (`gl_FragColor` 같은), '함수', '타입'이 있다. 이 예시에서는 실수 정밀도의 4차원 벡터 `vec4`가 보인다. 나중에는 일반적인 `float`, `int`, `bool`과 함께 `vec3`와 `vec2` 등 여러 타입을 보게 된다.

4. `vec4` 타입을 자세히 보면 네 개의 인수가 각각 빨강, 녹색, 파랑, 알파 채널에 대응한다. 또 이 값들이 `0.0`에서 `1.0` 사이로 '정규화'되어 있다는 점을 볼 수 있다. 이후에 값의 정규화가 어떻게 변수 사이의 값 *매핑*을 쉽게 만들어주는지 배울 것이다.

5. 또다른 중요한 'C 요소'가 전처리기 매크로의 존재다. 매크로는 컴파일 전 단계의 일부로 `#define` 전역 변수를 정의할 수 있고 (`#ifdef`와 `#endif`로) 간단한 조건 연산이 가능하다. 모든 매크로 명령어는 해시태그(`#`)로 시작한다. 컴파일 이전 단계는 컴파일 바로 전에 진행되어 `#defines`에 대한 모든 호출을 복사하고 `#ifdef`(정의됨)와 `#ifndef`(정의되지 않음) 조건을 확인한다. 위 "Hello World!" 예시에서는 `GL_ES` 정의 여부를 확인하는 줄만 넣었는데, 대체로 코드가 모바일 장치나 브라우저에서 컴파일될 때 실행되는 부분이다.

6. 실수 타입들은 셰이더에서 필수적이기 때문에 '정밀도'가 정말로 중요하다. 정밀도가 낮으면 렌더링이 빠르지만 퀄리티를 희생한다. 필요하다면 실수를 사용하는 변수마다 정밀도를 지정해줄 수도 있다. 위 예시에서는 `precision mediump float;`로 모든 실수 정밀도를 중간으로 설정한다. 필요하면 낮게 (`precision lowp float;`) 혹은 높게 (`precision highp float;`) 설정할 수 있다.

7. 마지막으로 가장 중요할지도 모르는 부분이 GLSL 규격에서는 변수들 타입이 자동으로 변환된다고 장담할 수 없다. 무슨 뜻인가? 제조사마다 그래픽 처리를 가속하는 접근법이 다르지만 최소한의 규격은 맞추도록 되어있다. 그런데 자동 형변환은 그 안에 없다. "Hello World!" 예시에서 `vec4`는 실수 정밀도를 가지고 있으니 `float`가 대입되기를 기대한다. 일관된 코드를 쓰고 싶고 하얀 화면을 디버깅하느라 몇 시간을 소모하고 싶지 않다면 실수들에 점(`.`)을 찍는 데 익숙해지자. 다음과 같은 코드는 항상 작동한다는 보장이 없다.

```glsl
void main() {
	gl_FragColor = vec4(1,0,0,1);	// ERROR
}
```

이제 우리 "Hello World!" 프로그램에서 중요한 요소들을 설명했으니 예시 코드를 클릭해서 배운 것들을 곱씹어 볼 시간이다. 오류가 있다면 프로그램은 컴파일에 실패하고 하얀 화면이 나온다. 몇 가지 시도해볼 흥미로운 부분들이 있다.

* 실수 값들을 정수로 바꾸어보자. 그래픽 카드에 따라 용서해줄 수도 있고 아닐 수도 있다.

* 6번 줄을 주석 처리하고 함수에 아무런 픽셀 값도 대입하지 말아보자.

* `main()` 안에 특정 색상을 반환하는 별개의 함수를 만들어보자. 힌트를 주자면 다음 함수는 빨간색을 반환한다:

```glsl
vec4 red(){
    return vec4(1.0,0.0,0.0,1.0);
}
```

* `vec4` 타입을 구성하는 방법은 여러가지다. 다른 방법들을 찾아보자. 다음의 한 가지 예다:

```glsl
vec4 color = vec4(vec3(1.0,0.0,1.0),1.0);
```

이 예시 자체가 그리 흥미롭지는 않지만 가장 기본적인 예시다. 캔버스 속 모든 픽셀을 정확히 같은 색으로 바꿔본 것이다. 다음 챕터에서는 공간(화면 위 픽셀의 위치)과 시간(페이지가 로드된 두 흐른 초 수) 두 가지 유형의 입력을 사용해 픽셀의 색을 바꾸는 방법을 알아보자.
